

- **为什么会OOM？**
- **哪些内存需要被回收？**



需要回收的内存即要回收的垃圾，就是那些**不可能再被任何途径使用的对象**。



确定一个对象是需要回收的垃圾，有以下两种方法：

2.1**引用计数法**

给对象添加一个引用计数器，当有其他对象引用该对象时，计数器+1；当引用失效时，计数器-1。

该算法原理简单，容易实现。但是，无法解决对象间循环引用的问题，所以主流的JVM中均没有采用这种算法。



2.2**可达性分析**



基本思路是找一些对象作为遍历的起始点（**成为GC Roots**），从这些起始点开始搜索，当某个对象并没有和任何GC Root产生关联，则认为这个对象已经不被使用了，可以清除。



GC Roots 的种类：

1.虚拟机栈：栈帧中的本地变量表引用的对象
2.native方法引用的对象
3.方法区中的静态变量和常量引用的对象





- **什么时候回收？**

- **非堆不够用的****Metaspace GC**
- **old区不够用的Major GC**
- **Eden区、survivor区不够用的Minor GC**
- **system.gc()**







- **垃圾如何回收？**



serial ： 单线程 GC STW  复制算法  应用线程--》  serial GC 线程 应用暂停--》应用线程  --无奈之选



ParNew ： serial 的多线程版本  STW  并行强依赖多线程代码，对比喻serial 缩短了业务线程的停顿时间

吞吐量 = 业务代码时间/(业务代码时间 + Gc时间)  99/(99+1) = 99%



Parallel Scavenage:  复制算法 多线程 更加关注吞吐量 也叫吞吐优先收集器

-XX:MaxGcPauseMillis  控制停顿时间 大于0   尽可能保证

-XX:GcTimeRatio  (0 -100) 19 垃圾收集时间1/(1+19) = 5%



Parallel old: 多线程 标记整理算法



并发类的垃圾收集器：

CMS 分之思想  标记-清除 

两种模式 

background  ： 1.7之前初始标记串行  1.8之后 并行

-XX:+CMSParallellnitialMarkEnabled

并发模式失败 foreground：切换其他垃圾收集器

-XX:+CMSInitiatingOccupancyFraction = 80     设定会收阈值  默认-1 不开启  百分比值

-XX:+CMSInitiatingOccupancyOnly 辅助上面的参会持久生效

CMS  到了80后台扫描线程 2秒一次



1.CMS GC 在实现上分成 foreground collector 和 background collector
2.foreground collector 触发条件比较简单，一般是遇到对象分配但空间不够，就会直接触发 GC，来立即进行空间回收。采用的算法是 mark sweep，不压缩。
3.每次扫描过程中，先等 CMSWaitDuration 时间，然后再去进行一次 shouldConcurrentCollect 判断，看是否满足 CMS background collector 的触发条件。CMSWaitDuration 默认时间是 2s
background collector 一共有 5 种触发情况：
1.是否是并行 Full GC
2.根据统计数据动态计算
3.根据 Old Gen 情况判断
a）Old Gen 空间使用占比情况与阈值比较，如果大于阈值则进行 CMS GC 也就是"occupancy() > initiatingoccupancy()"，occupancy 毫无疑问是 Old Gen 当前空间的使用占比
b)接下来没有配置 UseCMSInitiatingOccupancyOnly 的情况：
这里也分成有两小类情况：
当 Old Gen 刚因为对象分配空间而进行扩容，且成功分配空间，这时会考虑进行一次 CMS GC;
根据 CMS Gen 空闲链判断，这里有点复杂，目前也没整清楚，好在按照默认配置其实这里返回的是 false，所以默认是不用考虑这种触发条件了。

4.根据增量 GC 是否可能会失败(悲观策略)

5.根据 meta space 情况判断





CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)

- **初始标记**（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是**标记出GCRoots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
- **并发标记**（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
- **重新标记**（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。
- **并发清除**（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。

由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。

另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，**而是当堆内存使用率达到某一阈值时**，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

CMS收集器的垃圾收集算法采用的是**标记清除算法**，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。



### G1

因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。

G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先



### G1 垃圾收集器适用场景：

面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）

### G1 垃圾收集器的优缺点：

![image-20200714075738203](http://note.moguit.cn/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714075738203.png)
