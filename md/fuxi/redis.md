redis 特点

## 1.速度快

官方给出的数字是读写性能可以达到10万/秒

- Redis的所有数据都是存放在内存中的，所以把数据放在内存中是Redis速度快的最主要原因。
- Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- Redis使用了单线程架构，预防了多线程可能产生的竞争问题。

## 2.基于键值对的数据结构服务器

它主要提供了5种数据结构：字符串、哈希、列表、集合、有序集合。

## 3.丰富的功能

- 提供了键过期功能，可以用来实现缓存。
- 提供了发布订阅功能，可以用来实现消息系统。
- 支持Lua脚本功能，可以利用Lua创造出新的Redis命令。
- 提供了简单的事务功能，能在一定程度上保证事务特性。
- 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到Redis，减少了网络的开销。

​	

## 4.简单稳定

- Redis的源码很少。

- Redis使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。

- Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖libevent这样的系统类库），Redis自己实现了事件处理的相关功能。
  Redis虽然很简单，但是不代表它不稳定。维护的上千个Redis为例，没有出现过因为Redis自身bug而宕掉的情况。

- ## 5.客户端语言多

  Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入到Redis，并且由于Redis受到社区和各大公司的广泛认可，所以支持Redis的客户端语言也非常多，几乎涵盖了主流的编程语言，例如Java、PHP、Python、C、C++、Nodejs等。

- ## 6.持久化

  通常看，将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失，因此Redis提供了两种持久化方式：RDB和AOF，即可以用两种策略将内存的数据保存到硬盘中（如图所示）这样就保证了数据的可持久性。

- ![img](http://i2.51cto.com/images/blog/201810/24/d670124e310b4d81fd97666321bc5bc9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)

## 7.主从复制

Redis提供了复制功能，实现了多个相同数据的Redis副本（如图所示），复制功能是分布式Redis的基础。

![img](http://i2.51cto.com/images/blog/201810/24/97c11b3d7dcc80b2814fc95c7f29facb.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)





主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
从数据库一般都是只读的，并且接收主数据库同步过来的数据

特征：一个master可以拥有多个slave，一个slave只对应一个master

职责：

- master:
- 写数据
- 执行写操作时，将出现变化的数据自动同步到slave
- 读数据(可忽略)
- slave:
  - 读数据
  - 写数据(禁止)

### **主从复制的作用**

读写分离：master写、slave读，提高服务器的读写负载能力

负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量

故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复

数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式

高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案



**主从复制原理**

如果Slave（从节点）是第一次跟Master进行连接，

- **那么会首先会向Master发送同步请求psync；**
- **主节点接收到同步请求，开始fork主子进程开始进行全量同步，然后生成RDB文件；**
- **这个时候主节点同时会将新的写请求，保存到缓存区（buffer）中；**
- **从节点接收到RDB文件后，先清空老数据，然后将RDB中数据加载到内存中；**
- **等到从节点将RDB文件同步完成后再同步缓存区中的写请求。**

这里有一点需要注意的就是，主节点的缓存区是有限的，内部结构是一个环形数组，当数组被占满之后就会覆盖掉最早之前的数据。

所以如果由于网络或是其他原因，造成缓存区中的数据被覆盖了，那么当从节点处理完主节点的RDB文件后，就不得不又要进行一全量的RDB文件的复制，才能保证主从节点的数据一致。

如果不设置好合理的buffer区空间，是会造成一个RDB复制的死循环。

**当主从间的数据同步完成之后，后面主节点的每次写操作就都会同步到从节点，这样进行增量同步了。**



### 主从复制工作机制

主从复制过程大体可以分为3个阶段

建立连接阶段(即准备阶段)

建立slave到master的连接，使master能够识别slave，并保存slave端口号

数据同步阶段

在slave初次连接master后，复制master中的所有数据到slave

将slave的数据库状态更新成master当前的数据库状态

命令传播阶段

当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播，master将接收到的数据变更命令发送给slave，slave接收命令后执行命令

## 哨兵模式

哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。

(1)监控主服务器和从服务器是否正常运行。
(2)主服务器出现故障时自动将从服务器转换为主服务器。

注意：

- 哨兵也是一台redis服务器，只是不提供数据服务
- 通常哨兵配置数量为单数

### **哨兵模式的优缺点**

优点：

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。



哨兵可以监控Redis集群的健康状态，当主节点挂掉之后，选举出新的主节点。客户端在使用Redis的时候会先通过Sentinel来获取主节点地址，然后再通过主节点来进行数据交互。当主节点挂掉之后，客户端会再次向Sentinel获取主节点，这样客户端就可以无感知地继续使用了。

![img](https://pic1.zhimg.com/80/v2-cb618b1d405515fbe097f3f127e4ea10_720w.jpg)



**哨兵集群工作过程，主节点挂掉之后会选举出新的主节点，然后监控挂掉的节点，当挂掉的节点恢复后，原先的主节点就会变成从节点，从新的主节点那里建立主从关系。**



![img](https://pic4.zhimg.com/80/v2-6f1404cbaac04f8d6865fd1ae031c2a3_720w.jpg)





## 8.高可用和分布式

Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis节点的故障发现和故障自动转移。Redis从3.0版本正式提供了分布式实现Redis Cluster，它是Redis真正的分布式实现，提供了高可用、读写和容量的扩展性。

## Redis-Cluster集群

Redis-Cluster采用无中心结构,它的特点如下：

所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。

节点的fail是通过集群中超过半数的节点检测失效时才生效。

客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

工作方式：

在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。

![image-20211115150207920](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211115150207920.png)





redis 过期策略：

![image-20210917162115694](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20210917162115694.png)

- ***redis 按照绝对时间点过期的比如 现在4点 设置4.01过期，如果另外一台redis 时间是5点，你把4点这台机器上所有key同步到5点这台就会导致所有的key都过期了***





## **为什么需要淘汰策略**

有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。



淘汰策略：

1.no-envicition：
该策略对于写请求不再提供服务，会直接返回错误，当然排除del等特殊操作，redis默认是no-envicition策略。

2.allkeys-random：
从redis中随机选取key进行淘汰

3.allkeys-lru：
使用LRU（Least Recently Used，最近最少使用）算法，从redis中选取使用最少的key进行淘汰

4.volatile-random：
从redis中设置过过期时间的key，进行随机淘汰

5.volatile-ttl：
从redis中选取即将过期的key，进行淘汰

6.volatile-lru：
使用LRU（Least Recently U

sed，最近最少使用）算法，从redis中设置过过期时间的key中，选取最少使用的进行淘汰

7.volatile-lfu:
使用LFU（Least Frequently Used，最不经常使用），从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉

8.allkeys-lfu:
使用LFU（Least Frequently Used，最不经常使用），从所有的键中选择某段时间之内使用频次最少的键值对清除



总结：这八种大体上可以分为4中，lru、lfu、random、ttl。



lru：淘汰最近最少访问的数据，就是最访问的时间远的淘汰

lfu: 淘汰最近最少访问次数的数据，访问次数有关



缓存穿透：

redis和mqsql 都没有

解决：布隆过滤器，步骤1 数据加载到布隆过滤器 gavaa 提供了

位图是实现布隆过滤器的基础，布隆过滤器在位图上的优化，提供多个哈希值





分布式锁的设计应该是：

- 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
- 这把锁要是一把可重入锁，另外还要具备锁失效机制（避免死锁）
- 这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
- 有高可用的获取锁和释放锁功能
- 获取锁和释放锁的性能要好



redis热key是什么，怎么解决？

redis的大key和热key实际上就是经常被访问的key或者占用空间比较大的key。

。根据业务经验判断

比如做一个秒杀系统，根据要秒杀的商品就可以知道哪些key会成为热key，但是不是所有的业务都能这样判断。

。客户端代码进行数据手收集和统计，但是也存在一个问题，代码侵入

。使用facebookarchive/redis-faina

但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能

。利用2级缓存 备份热key monitor命令



redis 应用场景：

- 缓存
- 排行榜
- 计数器应用
- 共享Session
- 分布式锁
- 社交网络
- 消息队列
- 位操作



# Redis分布式锁缺点

就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。

但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。

接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。

此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。

所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：

**在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。**



## Redisson原理分析

![img](https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190618183025891-1248337684.jpg)







# Redisson、Jedis、Lettuce各有什么优缺点？

Redisson

优点：

实现了分布式特性和可扩展的 Java 数据结构，适合分布式开发
API 线程安全
基于 Netty 框架的事件驱动的通信，可异步调用
缺点：

API 更抽象，学习使用成本高


Jedis

优点：

提供了比较全面的 Redis 操作特性的 API
API 基本与 Redis 的指令一一对应，使用简单易理解
缺点：

同步阻塞 IO
不支持异步
线程不安全


Lettuce

优点：

线程安全
基于 Netty 框架的事件驱动的通信，可异步调用
适用于分布式缓存
缺点：

API 更抽象，学习使用成本高




![image-20211115202652423](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211115202652423.png)



1.redis 是一个基于缓存操作的key value 形式的数据存储

2.string hash set zset list

3

1）基于内存操作

2）单线程**避免了线程的上下文切换，也避免了线程竞争产生的死锁等问题**

3）  **使用I/O多路复用模型，非阻塞IO**多路复用**非阻塞IO**

4）**数据结构设计高效，例如String是由动态字符数组构成，zset内部的跳表；**

5.所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。



目前业内的方案有两种：

1）***利用二级缓存 *** 在你发现热key以后，把热key加载到系统的JVM中。 针对这种热key请求，会直接从jvm中取，而不会走到redis层。

2）***备份热key** *   这个方案也很简单。不要让key走到同一台redis上不就行了 我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。



7.

1）配合关系型数据库做高速缓存 ，缓存高频次访问的数据，降低数据库io， 分布式架构，做session共享

2）可以持久化特定数据。利用zset类型可以存储排行榜 利用list的自然时间排序存储最新n个数据



8。

两种方式：rdb（redis database）和aof（append of file）

RDB：在指定时间间隔内，将内存中的数据作为一个快照文件（snapshot）写入到磁盘，读取的时候也是直接读取snapshot文件到内存中

AOF : 以日志形式记录每个写操作，启动时通过日志恢复操作 ， 开启AOF：默认不开启，进入redis.conf找到appendonly yes打开



RDB和AOF对比 1.  节省磁盘空间 2恢复速度快

ROD缺点：
1.   数据太大时，比较消耗性能
\2.  一段时间保存一次快照，宕机时最后一次可能没有保存

AOF优点：
1.备份机制更加稳健
2.可读的日志文件，通过aof恢复更加稳健，可以处理失误



AOF缺点：
1.比RDB更占磁盘
2.备份速度较慢
3.iii每次都同步日志，有性能压力

9.

*Redis 集群怎么实现高可用**

高可用首先要解决集群部分失败的场景



10.

1)注意死锁

2)在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。**



11. 见上图



12。

1. 获得当前时间（ms）
2. 首先设置一个锁有效时间valid_time，也就是超过这个时间后锁自动释放，使用相同的key和value对所有redis实例进行设置，每次链接redis实例时设置一个小于valid_time的超时时间，比如valid_time时10s，那超时时间可以设置成50ms，如果这个实例不行，那么换下一个设置
3. 计算获取锁总共占用的时间，再加上时钟偏移，如果这个总时间小于valid_time，并且成功设置锁的实例数>= N/2 + 1，那么加锁成功
4. 如果加锁成功了，那么这个锁的有效时间就是valid_time - 获取锁占用的时间 - 时钟偏移
5. 如果加锁失败，解锁所有实例（每个redis实例都运行del key）



13.

https://blog.csdn.net/weixin_41622183/article/details/91126155



14。

- \1. 先更新数据库，再更新缓存
- \2. 先删除缓存，再更新数据库
- \3. 先更新数据库，再删除缓存

## 先更新数据库，再更新缓存 这套方案，大家是普遍反对的。为什么呢？有如下两点原因。

**原因一（线程安全角度）** 同时有请求A和请求B进行更新操作，那么会出现

- （1）线程A更新了数据库
- （2）线程B更新了数据库
- （3）线程B更新了缓存
- （4）线程A更新了缓存

这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。

**原因二（业务场景角度）** 有如下两点：

- （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。
- （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。

接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。

## 先删缓存，再更新数据库

该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:

- （1）请求A进行写操作，删除缓存
- （2）请求B查询发现缓存不存在
- （3）请求B去数据库查询得到旧值
- （4）请求B将旧值写入缓存
- （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。

那么，**如何解决呢？采用延时双删策略** 伪代码如下

```java
public void write(String key,Object data){
        redis.delKey(key);
        db.updateData(data);
        Thread.sleep(1000);
        redis.delKey(key);
    }
```

转化为中文描述就是

- （1）先淘汰缓存
- （2）再写数据库（这两步和原来一样）
- （3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。



15.

Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。

但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。



16.

![image-20211117131808932](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211117131808932.png)

事务以`MULTI`命令开始，然后将多个命令放到事务当中，最后由`EXEC`命令将这个事务提交给服务器执行。



watch 命令监控事务中的key 对应的value 是否修改，修改了会拒绝执行事务，告知事务安全性被破坏



17.

Redis 中的 Hash和 Java的 HashMap 更加相似,都是数组+链表的结构.当发生 hash 碰撞时将会把元素追加到链表上
我们先来了解下 hash 的内部结构.第一维是数组,第二维是链表.组成一个 hashtable.
在 Java 中 HashMap 扩容是个很耗时的操作,需要去申请新的数组，扩容的成本并不低，因为需要遍历一个时间复杂度为O(n)的数组，并且为其中的每个enrty进行hash计算。加入到新数组中
为了追求高性能,Redis 采用了渐进式 rehash 策略.这也是 hash 中最重要的部分.
redis在扩容的时候执行 rehash 策略会保留新旧两个 hashtable 结构，查询时也会同时查询两个 hashtable.Redis会将旧 hashtable 中的内容一点一点的迁移到新的 hashtable 中,当迁移完成时,就会用新的 hashtable 取代之前的.当 hashtable 移除了最后一个元素之后,这个数据结构将会被删除.
数据搬迁的操作放在 hash 的后续指令中,也就是来自客户端对 hash 的指令操作.一旦客户端后续没有指令操作这个 hash.Redis就会使用定时任务对数据主动搬迁.

18.

**可以的**，Redis提供两个指令生成RDB，分别是**save和bgsave**。

- 如果是save指令，会阻塞，因为是主线程执行的。
- 如果是bgsave指令，是fork一个子进程来写入RDB文件的，快照持久化完全交给子进程来处理，父进程则可以继续处理客户端的请求。



![image-20211227175717488](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211227175717488.png)
