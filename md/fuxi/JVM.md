**JVM**

**什么是JVM？**

JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。它由三个子系统构成，分别是类加载子系统、JVM 运行时数据区和执行引擎。



**JRE、JVM、JDK三者的关系**

JDK即**Java Development Kit**，是Java程序员常用的开发包、目的就是用来编译和调试Java程序的。它包括JRE和JVM。



JRE即**Java Runtime Environment**。，是指Java运行环境，也就是我们的写好的程序必须在JRE才能够运行。

JVM是Java虚拟机的缩写，是指负责将字节码解释成为特定的机器码进行运行，值得注意的是在运行过程中，Java源程序需要通过编译器编译为.class文件，否则JVM不认识。



![image-20211110095850698](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211110095850698.png)



**JVM运行时数据区**

JVM运行时数据区是数据的存储和逻辑运算。

JVM运行时数据区的组成部分组成部分包括堆、方法区、栈、本地方法栈、程序计算器等部分组成的，其中方法回收堆和方法区是共享区，也就是谁都可以使用，而栈和程序计算器、本地方法栈区是归JVM的。



**程序计数器**

指向当前线程正在执行的字节码指令的地址（行号）。

java中最小的执行单位是线程，因为虚拟机的是多线程的，每个线程是抢夺cpu时间片，程序计数器就是存储这些指令去做什么，比如循环，跳转，异常处理等等需要依赖它。每个线程都有属于自己的程序计数器，而且互不影响，独立存储。



**虚拟机栈**

**栈是数据结构，**用于存储当前线程运行方法时所需要的数据、指令、返回地址。

与程序计数器一样，Java的虚拟机栈也是线程私有的，虚拟机栈描述的是Java的方法执行的内存模型，方法每个执行在同时的创建都会一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。



![image-20211025135324265](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211025135324265.png)







栈帧：
1.局部变量

2.操作数栈

3.动态链接（方法动态调用过程）

4.返回地址

5.即时信息  （3.4.5 统称栈帧信息）



![image-20211109153843367](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211109153843367.png)



**本地方法栈**

本地方法栈和虚拟机栈相似，区别就是虚拟机为虚拟机栈执行Java服务（字节码服务），而本地方法栈为虚拟机使用到的Native方法服务。本地方法栈中使用的语言，使用方式，数据结构没有强制要求。主要作用是登记native方法，然后在execution engine执行的时候加载本地方法库。



**方法区**

它用于存储已被虚拟机加载的类信息（class文件）、常量（1.7有变化存储在堆里面）、静态变量（static）、JIT（即时编译器）编译后的代码等数据。



![image-20211109153943472](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211109153943472.png)





![image-20211109154026850](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211109154026850.png)





**堆（Heap）**

堆是 JVM 所管理的最大的一块内存空间，被所有线程共享，主要用于存放各种类的实例对象。堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

java堆是垃圾收集管理的主要区域，**现在收集器基本都采用分代收集方法**。最为常见的就是将整个Java堆分为新生代和老年代。无论怎么划分都是为了更好的回收，分配，利用内存。



**新生代**

新生代划分为三个区，eden区、s0和s1（s0和s1也被称为from和to区域，他们是两块大小相等并且可以互相角色的空间）；

Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小（8:1:1）



绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。



**老年代**

少部分对象存活周期比较长，或者因为一些特殊原因会进入到老年代。



**永久代**

JVM 里的永久代其实就是方法区，可以认为永久代就是放一些类信息的。



![image-20211025144037520](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211025144037520.png)





![image-20211025144125083](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211025144125083.png)





![image-20211025144543830](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211025144543830.png)

# **以 ObjectA a = new ObjectA(); 为例**

聊一聊，对象在 JVM 虚拟机中是如何`创建`的，在什么地方分配`内存`，又是如何`分配`的，对象是如何`定位`的，以及对象的内存`布局`，最后又是如何`回收`的。



## **1）对象的创建**

先在虚拟机栈创建栈帧，栈帧内创建对象的引用，在方法区进行类的加载，然后去 Java 堆区进行分配内存并内存初始化，再回到栈帧中初始化对象的数据，完成对象的创建。见下图：

![image-20211109154357890](C:\Users\EDZ\AppData\Roaming\Typora\typora-user-images\image-20211109154357890.png)